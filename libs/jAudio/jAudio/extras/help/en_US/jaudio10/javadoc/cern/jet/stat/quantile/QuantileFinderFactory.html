<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_16) on Thu Jan 01 00:27:43 EST 1970 -->
<TITLE>
QuantileFinderFactory
</TITLE>

<META NAME="keywords" CONTENT="cern.jet.stat.quantile.QuantileFinderFactory class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="QuantileFinderFactory";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../cern/jet/stat/quantile/Quantile1Test.html" title="class in cern.jet.stat.quantile"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?cern/jet/stat/quantile/QuantileFinderFactory.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="QuantileFinderFactory.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
cern.jet.stat.quantile</FONT>
<BR>
Class QuantileFinderFactory</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../resources/inherit.gif" ALT="extended by "><B>cern.jet.stat.quantile.QuantileFinderFactory</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>QuantileFinderFactory</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
Factory constructing exact and approximate quantile finders for both known and unknown <tt>N</tt>.
 Also see <A HREF="../../../../hep/aida/bin/QuantileBin1D.html" title="class in hep.aida.bin"><CODE>QuantileBin1D</CODE></A>, demonstrating how this package can be used.

 The approx. algorithms compute approximate quantiles of large data sequences in a single pass.
 The approximation guarantees are explicit, and apply for arbitrary value distributions and arrival distributions of the data sequence.
 The main memory requirements are smaller than for any other known technique by an order of magnitude.

 <p>The approx. algorithms are primarily intended to help applications scale.
 When faced with a large data sequences, traditional methods either need very large memories or time consuming disk based sorting.
 In constrast, the approx. algorithms can deal with > 10^10 values without disk based sorting.

 <p>All classes can be seen from various angles, for example as
 <dt>1. Algorithm to compute quantiles.
 <dt>2. 1-dim-equi-depth histogram.
 <dt>3. 1-dim-histogram arbitrarily rebinnable in real-time.
 <dt>4. A space efficient MultiSet data structure using lossy compression.
 <dt>5. A space efficient value preserving bin of a 2-dim or d-dim histogram.
 <dt>(All subject to an accuracy specified by the user.)
 
 <p>Use methods <tt>newXXX(...)</tt> to get new instances of one of the following quantile finders.

 <p><b>1. Exact quantile finding algorithm for known and unknown <tt>N</tt> requiring large main memory.</b></p>
 The folkore algorithm: Keeps all elements in main memory, sorts the list, then picks the quantiles.

 

 
 <p><p><b>2. Approximate quantile finding algorithm for known <tt>N</tt> requiring only one pass and little main memory.</b></p>

 <p>Needs as input the following parameters:<p>
 <dt>1. <tt>N</tt> - the number of values of the data sequence over which quantiles are to be determined.
 <dt>2. <tt>quantiles</tt> - the number of quantiles to be computed. If unknown in advance, set this number large, e.g. <tt>quantiles &gt;= 10000</tt>.
 <dt>3. <tt>epsilon</tt> - the allowed approximation error on quantiles. The approximation guarantee of this algorithm is explicit.

 <p>It is also possible to couple the approximation algorithm with random sampling to further reduce memory requirements. 
 With sampling, the approximation guarantees are explicit but probabilistic, i.e. they apply with respect to a (user controlled) confidence parameter "delta".

 <dt>4. <tt>delta</tt> - the probability allowed that the approximation error fails to be smaller than epsilon. Set <tt>delta</tt> to zero for explicit non probabilistic guarantees.
 
 <p>After Gurmeet Singh Manku, Sridhar Rajagopalan and Bruce G. Lindsay, 
 Approximate Medians and other Quantiles in One Pass and with Limited Memory,
 Proc. of the 1998 ACM SIGMOD Int. Conf. on Management of Data,
 Paper available <A HREF="http://www-cad.eecs.berkeley.edu/~manku/papers/quantiles.ps.gz"> here</A>.

 


 <p><p><b>3. Approximate quantile finding algorithm for unknown <tt>N</tt> requiring only one pass and little main memory.</b></p>
 This algorithm requires at most two times the memory of a corresponding approx. quantile finder knowing <tt>N</tt>.

 <p>Needs as input the following parameters:<p>
 <dt>2. <tt>quantiles</tt> - the number of quantiles to be computed. If unknown in advance, set this number large, e.g. <tt>quantiles &gt;= 1000</tt>.
 <dt>2. <tt>epsilon</tt> - the allowed approximation error on quantiles. The approximation guarantee of this algorithm is explicit.

 <p>It is also possible to couple the approximation algorithm with random sampling to further reduce memory requirements. 
 With sampling, the approximation guarantees are explicit but probabilistic, i.e. they apply with respect to a (user controlled) confidence parameter "delta".

 <dt>3. <tt>delta</tt> - the probability allowed that the approximation error fails to be smaller than epsilon. Set <tt>delta</tt> to zero for explicit non probabilistic guarantees.
 
 <p>After Gurmeet Singh Manku, Sridhar Rajagopalan and Bruce G. Lindsay,
 Random Sampling Techniques for Space Efficient Online Computation of Order Statistics of Large Datasets.
 Proc. of the 1999 ACM SIGMOD Int. Conf. on Management of Data,
 Paper available <A HREF="http://www-cad.eecs.berkeley.edu/~manku/papers/unknown.ps.gz"> here</A>.

 <p><b>Example usage:</b>
 
<pre>
 _TODO_
</pre><p>
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>wolfgang.hoschek@cern.ch</DD>
<DT><B>See Also:</B><DD><CODE>KnownDoubleQuantileEstimator</CODE>, 
<CODE>UnknownDoubleQuantileEstimator</CODE></DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../cern/jet/stat/quantile/QuantileFinderFactory.html#QuantileFinderFactory()">QuantileFinderFactory</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make this class non instantiable.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../cern/jet/stat/quantile/QuantileFinderFactory.html#known_N_compute_B_and_K_quick(long, double)">known_N_compute_B_and_K_quick</A></B>(long&nbsp;N,
                              double&nbsp;epsilon)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the number of buffers and number of values per buffer such that
 quantiles can be determined with a <b>guaranteed</b> approximation error no more than epsilon.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../cern/jet/stat/quantile/QuantileFinderFactory.html#known_N_compute_B_and_K_slow(long, double, double, int, double[])">known_N_compute_B_and_K_slow</A></B>(long&nbsp;N,
                             double&nbsp;epsilon,
                             double&nbsp;delta,
                             int&nbsp;quantiles,
                             double[]&nbsp;returnSamplingRate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the number of buffers and number of values per buffer such that
 quantiles can be determined with an approximation error no more than epsilon with a certain probability.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../cern/jet/stat/quantile/QuantileFinderFactory.html#known_N_compute_B_and_K(long, double, double, int, double[])">known_N_compute_B_and_K</A></B>(long&nbsp;N,
                        double&nbsp;epsilon,
                        double&nbsp;delta,
                        int&nbsp;quantiles,
                        double[]&nbsp;returnSamplingRate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the number of buffers and number of values per buffer such that
 quantiles can be determined with an approximation error no more than epsilon with a certain probability.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../cern/jet/stat/quantile/DoubleQuantileFinder.html" title="interface in cern.jet.stat.quantile">DoubleQuantileFinder</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../cern/jet/stat/quantile/QuantileFinderFactory.html#newDoubleQuantileFinder(boolean, long, double, double, int, cern.jet.random.engine.RandomEngine)">newDoubleQuantileFinder</A></B>(boolean&nbsp;known_N,
                        long&nbsp;N,
                        double&nbsp;epsilon,
                        double&nbsp;delta,
                        int&nbsp;quantiles,
                        <A HREF="../../../../cern/jet/random/engine/RandomEngine.html" title="class in cern.jet.random.engine">RandomEngine</A>&nbsp;generator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a quantile finder that minimizes the amount of memory needed under the user provided constraints.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../cern/colt/list/DoubleArrayList.html" title="class in cern.colt.list">DoubleArrayList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../cern/jet/stat/quantile/QuantileFinderFactory.html#newEquiDepthPhis(int)">newEquiDepthPhis</A></B>(int&nbsp;quantiles)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience method that computes phi's for equi-depth histograms.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../cern/jet/stat/quantile/QuantileFinderFactory.html#unknown_N_compute_B_and_K_raw(double, double, int)">unknown_N_compute_B_and_K_raw</A></B>(double&nbsp;epsilon,
                              double&nbsp;delta,
                              int&nbsp;quantiles)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the number of buffers and number of values per buffer such that
 quantiles can be determined with an approximation error no more than epsilon with a certain probability.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../cern/jet/stat/quantile/QuantileFinderFactory.html#unknown_N_compute_B_and_K(double, double, int)">unknown_N_compute_B_and_K</A></B>(double&nbsp;epsilon,
                          double&nbsp;delta,
                          int&nbsp;quantiles)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the number of buffers and number of values per buffer such that
 quantiles can be determined with an approximation error no more than epsilon with a certain probability.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="QuantileFinderFactory()"><!-- --></A><H3>
QuantileFinderFactory</H3>
<PRE>
protected <B>QuantileFinderFactory</B>()</PRE>
<DL>
<DD>Make this class non instantiable. Let still allow others to inherit.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="known_N_compute_B_and_K(long, double, double, int, double[])"><!-- --></A><H3>
known_N_compute_B_and_K</H3>
<PRE>
public static long[] <B>known_N_compute_B_and_K</B>(long&nbsp;N,
                                             double&nbsp;epsilon,
                                             double&nbsp;delta,
                                             int&nbsp;quantiles,
                                             double[]&nbsp;returnSamplingRate)</PRE>
<DL>
<DD>Computes the number of buffers and number of values per buffer such that
 quantiles can be determined with an approximation error no more than epsilon with a certain probability.

 Assumes that quantiles are to be computed over N values.
 The required sampling rate is computed and stored in the first element of the provided <tt>returnSamplingRate</tt> array, which, therefore must be at least of length 1.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>N</CODE> - the number of values over which quantiles shall be computed (e.g <tt>10^6</tt>).<DD><CODE>epsilon</CODE> - the approximation error which is guaranteed not to be exceeded (e.g. <tt>0.001</tt>) (<tt>0 &lt;= epsilon &lt;= 1</tt>). To get exact result, set <tt>epsilon=0.0</tt>;<DD><CODE>delta</CODE> - the probability that the approximation error is more than than epsilon (e.g. <tt>0.0001</tt>) (<tt>0 &lt;= delta &lt;= 1</tt>). To avoid probabilistic answers, set <tt>delta=0.0</tt>.<DD><CODE>quantiles</CODE> - the number of quantiles to be computed (e.g. <tt>100</tt>) (<tt>quantiles &gt;= 1</tt>). If unknown in advance, set this number large, e.g. <tt>quantiles &gt;= 10000</tt>.<DD><CODE>samplingRate</CODE> - output parameter, a <tt>double[1]</tt> where the sampling rate is to be filled in.
<DT><B>Returns:</B><DD><tt>long[2]</tt> - <tt>long[0]</tt>=the number of buffers, <tt>long[1]</tt>=the number of elements per buffer, <tt>returnSamplingRate[0]</tt>=the required sampling rate.</DL>
</DD>
</DL>
<HR>

<A NAME="known_N_compute_B_and_K_quick(long, double)"><!-- --></A><H3>
known_N_compute_B_and_K_quick</H3>
<PRE>
protected static long[] <B>known_N_compute_B_and_K_quick</B>(long&nbsp;N,
                                                      double&nbsp;epsilon)</PRE>
<DL>
<DD>Computes the number of buffers and number of values per buffer such that
 quantiles can be determined with a <b>guaranteed</b> approximation error no more than epsilon.
 Assumes that quantiles are to be computed over N values.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>N</CODE> - the anticipated number of values over which quantiles shall be determined.<DD><CODE>epsilon</CODE> - the approximation error which is guaranteed not to be exceeded (e.g. <tt>0.001</tt>) (<tt>0 &lt;= epsilon &lt;= 1</tt>). To get exact result, set <tt>epsilon=0.0</tt>;
<DT><B>Returns:</B><DD><tt>long[2]</tt> - <tt>long[0]</tt>=the number of buffers, <tt>long[1]</tt>=the number of elements per buffer.</DL>
</DD>
</DL>
<HR>

<A NAME="known_N_compute_B_and_K_slow(long, double, double, int, double[])"><!-- --></A><H3>
known_N_compute_B_and_K_slow</H3>
<PRE>
protected static long[] <B>known_N_compute_B_and_K_slow</B>(long&nbsp;N,
                                                     double&nbsp;epsilon,
                                                     double&nbsp;delta,
                                                     int&nbsp;quantiles,
                                                     double[]&nbsp;returnSamplingRate)</PRE>
<DL>
<DD>Computes the number of buffers and number of values per buffer such that
 quantiles can be determined with an approximation error no more than epsilon with a certain probability.
 Assumes that quantiles are to be computed over N values.
 The required sampling rate is computed and stored in the first element of the provided <tt>returnSamplingRate</tt> array, which, therefore must be at least of length 1.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>N</CODE> - the anticipated number of values over which quantiles shall be computed (e.g 10^6).<DD><CODE>epsilon</CODE> - the approximation error which is guaranteed not to be exceeded (e.g. <tt>0.001</tt>) (<tt>0 &lt;= epsilon &lt;= 1</tt>). To get exact result, set <tt>epsilon=0.0</tt>;<DD><CODE>delta</CODE> - the probability that the approximation error is more than than epsilon (e.g. <tt>0.0001</tt>) (<tt>0 &lt;= delta &lt;= 1</tt>). To avoid probabilistic answers, set <tt>delta=0.0</tt>.<DD><CODE>quantiles</CODE> - the number of quantiles to be computed (e.g. <tt>100</tt>) (<tt>quantiles &gt;= 1</tt>). If unknown in advance, set this number large, e.g. <tt>quantiles &gt;= 10000</tt>.<DD><CODE>samplingRate</CODE> - a <tt>double[1]</tt> where the sampling rate is to be filled in.
<DT><B>Returns:</B><DD><tt>long[2]</tt> - <tt>long[0]</tt>=the number of buffers, <tt>long[1]</tt>=the number of elements per buffer, <tt>returnSamplingRate[0]</tt>=the required sampling rate.</DL>
</DD>
</DL>
<HR>

<A NAME="newDoubleQuantileFinder(boolean, long, double, double, int, cern.jet.random.engine.RandomEngine)"><!-- --></A><H3>
newDoubleQuantileFinder</H3>
<PRE>
public static <A HREF="../../../../cern/jet/stat/quantile/DoubleQuantileFinder.html" title="interface in cern.jet.stat.quantile">DoubleQuantileFinder</A> <B>newDoubleQuantileFinder</B>(boolean&nbsp;known_N,
                                                           long&nbsp;N,
                                                           double&nbsp;epsilon,
                                                           double&nbsp;delta,
                                                           int&nbsp;quantiles,
                                                           <A HREF="../../../../cern/jet/random/engine/RandomEngine.html" title="class in cern.jet.random.engine">RandomEngine</A>&nbsp;generator)</PRE>
<DL>
<DD>Returns a quantile finder that minimizes the amount of memory needed under the user provided constraints.
  
 Many applications don't know in advance over how many elements quantiles are to be computed. 
 However, some of them can give an upper limit, which will assist the factory in choosing quantile finders with minimal memory requirements.  
 For example if you select values from a database and fill them into histograms, then you probably don't know how many values you will fill, but you probably do know that you will fill at most <tt>S</tt> elements, the size of your database.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>known_N</CODE> - specifies whether the number of elements over which quantiles are to be computed is known or not.<DD><CODE>N</CODE> - if <tt>known_N==true</tt>, the number of elements over which quantiles are to be computed.
                        if <tt>known_N==false</tt>, the upper limit on the number of elements over which quantiles are to be computed. 
                        If such an upper limit is a-priori unknown, then set <tt>N = Long.MAX_VALUE</tt>.<DD><CODE>epsilon</CODE> - the approximation error which is guaranteed not to be exceeded (e.g. <tt>0.001</tt>) (<tt>0 &lt;= epsilon &lt;= 1</tt>). To get exact result, set <tt>epsilon=0.0</tt>;<DD><CODE>delta</CODE> - the probability that the approximation error is more than than epsilon (e.g. 0.0001) (0 &lt;= delta &lt;= 1). To avoid probabilistic answers, set <tt>delta=0.0</tt>.<DD><CODE>quantiles</CODE> - the number of quantiles to be computed (e.g. <tt>100</tt>) (<tt>quantiles &gt;= 1</tt>). If unknown in advance, set this number large, e.g. <tt>quantiles &gt;= 10000</tt>.<DD><CODE>generator</CODE> - a uniform random number generator. Set this parameter to <tt>null</tt> to use a default generator.
<DT><B>Returns:</B><DD>the quantile finder minimizing memory requirements under the given constraints.</DL>
</DD>
</DL>
<HR>

<A NAME="newEquiDepthPhis(int)"><!-- --></A><H3>
newEquiDepthPhis</H3>
<PRE>
public static <A HREF="../../../../cern/colt/list/DoubleArrayList.html" title="class in cern.colt.list">DoubleArrayList</A> <B>newEquiDepthPhis</B>(int&nbsp;quantiles)</PRE>
<DL>
<DD>Convenience method that computes phi's for equi-depth histograms.
 This is simply a list of numbers with <tt>i / (double)quantiles</tt> for <tt>i={1,2,...,quantiles-1}</tt>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the equi-depth phi's</DL>
</DD>
</DL>
<HR>

<A NAME="unknown_N_compute_B_and_K(double, double, int)"><!-- --></A><H3>
unknown_N_compute_B_and_K</H3>
<PRE>
public static long[] <B>unknown_N_compute_B_and_K</B>(double&nbsp;epsilon,
                                               double&nbsp;delta,
                                               int&nbsp;quantiles)</PRE>
<DL>
<DD>Computes the number of buffers and number of values per buffer such that
 quantiles can be determined with an approximation error no more than epsilon with a certain probability.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>epsilon</CODE> - the approximation error which is guaranteed not to be exceeded (e.g. <tt>0.001</tt>) (<tt>0 &lt;= epsilon &lt;= 1</tt>). To get exact results, set <tt>epsilon=0.0</tt>;<DD><CODE>delta</CODE> - the probability that the approximation error is more than than epsilon (e.g. <tt>0.0001</tt>) (<tt>0 &lt;= delta &lt;= 1</tt>). To get exact results, set <tt>delta=0.0</tt>.<DD><CODE>quantiles</CODE> - the number of quantiles to be computed (e.g. <tt>100</tt>) (<tt>quantiles &gt;= 1</tt>). If unknown in advance, set this number large, e.g. <tt>quantiles &gt;= 10000</tt>.
<DT><B>Returns:</B><DD><tt>long[4]</tt> - <tt>long[0]</tt>=the number of buffers, <tt>long[1]</tt>=the number of elements per buffer, <tt>long[2]</tt>=the tree height where sampling shall start, <tt>long[3]==1</tt> if precomputing is better, otherwise 0;</DL>
</DD>
</DL>
<HR>

<A NAME="unknown_N_compute_B_and_K_raw(double, double, int)"><!-- --></A><H3>
unknown_N_compute_B_and_K_raw</H3>
<PRE>
protected static long[] <B>unknown_N_compute_B_and_K_raw</B>(double&nbsp;epsilon,
                                                      double&nbsp;delta,
                                                      int&nbsp;quantiles)</PRE>
<DL>
<DD>Computes the number of buffers and number of values per buffer such that
 quantiles can be determined with an approximation error no more than epsilon with a certain probability.
 <b>You never need to call this method.</b> It is only for curious users wanting to gain some insight into the workings of the algorithms.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>epsilon</CODE> - the approximation error which is guaranteed not to be exceeded (e.g. <tt>0.001</tt>) (<tt>0 &lt;= epsilon &lt;= 1</tt>). To get exact result, set <tt>epsilon=0.0</tt>;<DD><CODE>delta</CODE> - the probability that the approximation error is more than than epsilon (e.g. <tt>0.0001</tt>) (<tt>0 &lt;= delta &lt;= 1</tt>). To get exact results, set <tt>delta=0.0</tt>.<DD><CODE>quantiles</CODE> - the number of quantiles to be computed (e.g. <tt>100</tt>) (<tt>quantiles &gt;= 1</tt>). If unknown in advance, set this number large, e.g. <tt>quantiles &gt;= 10000</tt>.
<DT><B>Returns:</B><DD><tt>long[4]</tt> - <tt>long[0]</tt>=the number of buffers, <tt>long[1]</tt>=the number of elements per buffer, <tt>long[2]</tt>=the tree height where sampling shall start, <tt>long[3]==1</tt> if precomputing is better, otherwise 0;</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../cern/jet/stat/quantile/Quantile1Test.html" title="class in cern.jet.stat.quantile"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?cern/jet/stat/quantile/QuantileFinderFactory.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="QuantileFinderFactory.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
