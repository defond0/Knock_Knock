<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_16) on Thu Jan 01 00:28:33 EST 1970 -->
<TITLE>
Sorting
</TITLE>

<META NAME="keywords" CONTENT="cern.colt.Sorting class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Sorting";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../cern/colt/PersistentObject.html" title="class in cern.colt"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../cern/colt/Swapper.html" title="interface in cern.colt"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?cern/colt/Sorting.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Sorting.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
cern.colt</FONT>
<BR>
Class Sorting</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>cern.colt.Sorting</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>Sorting</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
Quicksorts, mergesorts and binary searches; complements <tt>java.util.Arrays</tt>.
 Contains, for example, the quicksort on Comparators and Comparables, which are still missing in <tt>java.util.Arrays</tt> of JDK 1.2.
 Also provides mergesorts for types not supported in <tt>java.util.Arrays</tt>, as well as a couple of other methods for primitive arrays.
 The quicksorts and mergesorts are the JDK 1.2 V1.26 algorithms, modified as necessary.
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>wolfgang.hoschek@cern.ch</DD>
<DT><B>See Also:</B><DD><A HREF="../../cern/colt/GenericSorting.html" title="class in cern.colt"><CODE>GenericSorting</CODE></A>, 
<A HREF="../../cern/colt/matrix/doublealgo/Sorting.html" title="class in cern.colt.matrix.doublealgo"><CODE>Sorting</CODE></A>, 
<CODE>Arrays</CODE></DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#Sorting()">Sorting</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Makes this class non instantiable, but still let's others inherit from it.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#binarySearchFromTo(byte[], byte, int, int)">binarySearchFromTo</A></B>(byte[]&nbsp;list,
                   byte&nbsp;key,
                   int&nbsp;from,
                   int&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Searches the list for the specified value using
 the binary search algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#binarySearchFromTo(char[], char, int, int)">binarySearchFromTo</A></B>(char[]&nbsp;list,
                   char&nbsp;key,
                   int&nbsp;from,
                   int&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Searches the list for the specified value using
 the binary search algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#binarySearchFromTo(double[], double, int, int)">binarySearchFromTo</A></B>(double[]&nbsp;list,
                   double&nbsp;key,
                   int&nbsp;from,
                   int&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Searches the list for the specified value using
 the binary search algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#binarySearchFromTo(float[], float, int, int)">binarySearchFromTo</A></B>(float[]&nbsp;list,
                   float&nbsp;key,
                   int&nbsp;from,
                   int&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Searches the list for the specified value using
 the binary search algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#binarySearchFromTo(int[], int, int, int)">binarySearchFromTo</A></B>(int[]&nbsp;list,
                   int&nbsp;key,
                   int&nbsp;from,
                   int&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Searches the list for the specified value using
 the binary search algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#binarySearchFromTo(int, int, cern.colt.function.IntComparator)">binarySearchFromTo</A></B>(int&nbsp;from,
                   int&nbsp;to,
                   <A HREF="../../cern/colt/function/IntComparator.html" title="interface in cern.colt.function">IntComparator</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generically searches the list for the specified value using
 the binary search algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#binarySearchFromTo(long[], long, int, int)">binarySearchFromTo</A></B>(long[]&nbsp;list,
                   long&nbsp;key,
                   int&nbsp;from,
                   int&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Searches the list for the specified value using
 the binary search algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#binarySearchFromTo(java.lang.Object[], java.lang.Object, int, int, java.util.Comparator)">binarySearchFromTo</A></B>(java.lang.Object[]&nbsp;list,
                   java.lang.Object&nbsp;key,
                   int&nbsp;from,
                   int&nbsp;to,
                   java.util.Comparator&nbsp;comparator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Searches the list for the specified value using
 the binary search algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#binarySearchFromTo(short[], short, int, int)">binarySearchFromTo</A></B>(short[]&nbsp;list,
                   short&nbsp;key,
                   int&nbsp;from,
                   int&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Searches the list for the specified value using
 the binary search algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#mergeSort(byte[], int, int)">mergeSort</A></B>(byte[]&nbsp;a,
          int&nbsp;fromIndex,
          int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified range of the specified array of elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#mergeSort(byte[], int, int, cern.colt.function.ByteComparator)">mergeSort</A></B>(byte[]&nbsp;a,
          int&nbsp;fromIndex,
          int&nbsp;toIndex,
          <A HREF="../../cern/colt/function/ByteComparator.html" title="interface in cern.colt.function">ByteComparator</A>&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#mergeSort(char[], int, int)">mergeSort</A></B>(char[]&nbsp;a,
          int&nbsp;fromIndex,
          int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified range of the specified array of elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#mergeSort(char[], int, int, cern.colt.function.CharComparator)">mergeSort</A></B>(char[]&nbsp;a,
          int&nbsp;fromIndex,
          int&nbsp;toIndex,
          <A HREF="../../cern/colt/function/CharComparator.html" title="interface in cern.colt.function">CharComparator</A>&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#mergeSort(double[], int, int)">mergeSort</A></B>(double[]&nbsp;a,
          int&nbsp;fromIndex,
          int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified range of the specified array of elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#mergeSort(double[], int, int, cern.colt.function.DoubleComparator)">mergeSort</A></B>(double[]&nbsp;a,
          int&nbsp;fromIndex,
          int&nbsp;toIndex,
          <A HREF="../../cern/colt/function/DoubleComparator.html" title="interface in cern.colt.function">DoubleComparator</A>&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#mergeSort(float[], int, int)">mergeSort</A></B>(float[]&nbsp;a,
          int&nbsp;fromIndex,
          int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified range of the specified array of elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#mergeSort(float[], int, int, cern.colt.function.FloatComparator)">mergeSort</A></B>(float[]&nbsp;a,
          int&nbsp;fromIndex,
          int&nbsp;toIndex,
          <A HREF="../../cern/colt/function/FloatComparator.html" title="interface in cern.colt.function">FloatComparator</A>&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#mergeSort(int[], int, int)">mergeSort</A></B>(int[]&nbsp;a,
          int&nbsp;fromIndex,
          int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified range of the specified array of elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#mergeSort(int[], int, int, cern.colt.function.IntComparator)">mergeSort</A></B>(int[]&nbsp;a,
          int&nbsp;fromIndex,
          int&nbsp;toIndex,
          <A HREF="../../cern/colt/function/IntComparator.html" title="interface in cern.colt.function">IntComparator</A>&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#mergeSort(long[], int, int)">mergeSort</A></B>(long[]&nbsp;a,
          int&nbsp;fromIndex,
          int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified range of the specified array of elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#mergeSort(long[], int, int, cern.colt.function.LongComparator)">mergeSort</A></B>(long[]&nbsp;a,
          int&nbsp;fromIndex,
          int&nbsp;toIndex,
          <A HREF="../../cern/colt/function/LongComparator.html" title="interface in cern.colt.function">LongComparator</A>&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#mergeSort(short[], int, int)">mergeSort</A></B>(short[]&nbsp;a,
          int&nbsp;fromIndex,
          int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified range of the specified array of elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#mergeSort(short[], int, int, cern.colt.function.ShortComparator)">mergeSort</A></B>(short[]&nbsp;a,
          int&nbsp;fromIndex,
          int&nbsp;toIndex,
          <A HREF="../../cern/colt/function/ShortComparator.html" title="interface in cern.colt.function">ShortComparator</A>&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#mergeSortInPlace(int[], int, int)">mergeSortInPlace</A></B>(int[]&nbsp;a,
                 int&nbsp;fromIndex,
                 int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified range of the specified array of elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#quickSort(byte[], int, int, cern.colt.function.ByteComparator)">quickSort</A></B>(byte[]&nbsp;a,
          int&nbsp;fromIndex,
          int&nbsp;toIndex,
          <A HREF="../../cern/colt/function/ByteComparator.html" title="interface in cern.colt.function">ByteComparator</A>&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#quickSort(char[], int, int, cern.colt.function.CharComparator)">quickSort</A></B>(char[]&nbsp;a,
          int&nbsp;fromIndex,
          int&nbsp;toIndex,
          <A HREF="../../cern/colt/function/CharComparator.html" title="interface in cern.colt.function">CharComparator</A>&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#quickSort(double[], int, int, cern.colt.function.DoubleComparator)">quickSort</A></B>(double[]&nbsp;a,
          int&nbsp;fromIndex,
          int&nbsp;toIndex,
          <A HREF="../../cern/colt/function/DoubleComparator.html" title="interface in cern.colt.function">DoubleComparator</A>&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#quickSort(float[], int, int, cern.colt.function.FloatComparator)">quickSort</A></B>(float[]&nbsp;a,
          int&nbsp;fromIndex,
          int&nbsp;toIndex,
          <A HREF="../../cern/colt/function/FloatComparator.html" title="interface in cern.colt.function">FloatComparator</A>&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#quickSort(int[], int, int, cern.colt.function.IntComparator)">quickSort</A></B>(int[]&nbsp;a,
          int&nbsp;fromIndex,
          int&nbsp;toIndex,
          <A HREF="../../cern/colt/function/IntComparator.html" title="interface in cern.colt.function">IntComparator</A>&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#quickSort(long[], int, int, cern.colt.function.LongComparator)">quickSort</A></B>(long[]&nbsp;a,
          int&nbsp;fromIndex,
          int&nbsp;toIndex,
          <A HREF="../../cern/colt/function/LongComparator.html" title="interface in cern.colt.function">LongComparator</A>&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#quickSort(java.lang.Object[])">quickSort</A></B>(java.lang.Object[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified range of the receiver into
 ascending order, according to the <i>natural ordering</i> of its
 elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#quickSort(java.lang.Object[], java.util.Comparator)">quickSort</A></B>(java.lang.Object[]&nbsp;a,
          java.util.Comparator&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified array according
 to the order induced by the specified comparator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#quickSort(java.lang.Object[], int, int)">quickSort</A></B>(java.lang.Object[]&nbsp;a,
          int&nbsp;fromIndex,
          int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified range of the receiver into
 ascending order, according to the <i>natural ordering</i> of its
 elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#quickSort(java.lang.Object[], int, int, java.util.Comparator)">quickSort</A></B>(java.lang.Object[]&nbsp;a,
          int&nbsp;fromIndex,
          int&nbsp;toIndex,
          java.util.Comparator&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified range of the specified array according
 to the order induced by the specified comparator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../cern/colt/Sorting.html#quickSort(short[], int, int, cern.colt.function.ShortComparator)">quickSort</A></B>(short[]&nbsp;a,
          int&nbsp;fromIndex,
          int&nbsp;toIndex,
          <A HREF="../../cern/colt/function/ShortComparator.html" title="interface in cern.colt.function">ShortComparator</A>&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Sorting()"><!-- --></A><H3>
Sorting</H3>
<PRE>
protected <B>Sorting</B>()</PRE>
<DL>
<DD>Makes this class non instantiable, but still let's others inherit from it.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="binarySearchFromTo(byte[], byte, int, int)"><!-- --></A><H3>
binarySearchFromTo</H3>
<PRE>
public static int <B>binarySearchFromTo</B>(byte[]&nbsp;list,
                                     byte&nbsp;key,
                                     int&nbsp;from,
                                     int&nbsp;to)</PRE>
<DL>
<DD>Searches the list for the specified value using
 the binary search algorithm.  The list must <strong>must</strong> be
 sorted (as by the sort method) prior to making this call.  If
 it is not sorted, the results are undefined: in particular, the call
 may enter an infinite loop.  If the list contains multiple elements
 equal to the specified key, there is no guarantee which of the multiple elements
 will be found.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>list</CODE> - the list to be searched.<DD><CODE>key</CODE> - the value to be searched for.<DD><CODE>from</CODE> - the leftmost search position, inclusive.<DD><CODE>to</CODE> - the rightmost search position, inclusive.
<DT><B>Returns:</B><DD>index of the search key, if it is contained in the list;
               otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
               point</i> is defined as the the point at which the value would
               be inserted into the list: the index of the first
               element greater than the key, or <tt>list.length</tt>, if all
               elements in the list are less than the specified key.  Note
               that this guarantees that the return value will be &gt;= 0 if
               and only if the key is found.<DT><B>See Also:</B><DD><CODE>Arrays</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="binarySearchFromTo(char[], char, int, int)"><!-- --></A><H3>
binarySearchFromTo</H3>
<PRE>
public static int <B>binarySearchFromTo</B>(char[]&nbsp;list,
                                     char&nbsp;key,
                                     int&nbsp;from,
                                     int&nbsp;to)</PRE>
<DL>
<DD>Searches the list for the specified value using
 the binary search algorithm.  The list must <strong>must</strong> be
 sorted (as by the sort method) prior to making this call.  If
 it is not sorted, the results are undefined: in particular, the call
 may enter an infinite loop.  If the list contains multiple elements
 equal to the specified key, there is no guarantee which of the multiple elements
 will be found.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>list</CODE> - the list to be searched.<DD><CODE>key</CODE> - the value to be searched for.<DD><CODE>from</CODE> - the leftmost search position, inclusive.<DD><CODE>to</CODE> - the rightmost search position, inclusive.
<DT><B>Returns:</B><DD>index of the search key, if it is contained in the list;
               otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
               point</i> is defined as the the point at which the value would
               be inserted into the list: the index of the first
               element greater than the key, or <tt>list.length</tt>, if all
               elements in the list are less than the specified key.  Note
               that this guarantees that the return value will be &gt;= 0 if
               and only if the key is found.<DT><B>See Also:</B><DD><CODE>Arrays</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="binarySearchFromTo(double[], double, int, int)"><!-- --></A><H3>
binarySearchFromTo</H3>
<PRE>
public static int <B>binarySearchFromTo</B>(double[]&nbsp;list,
                                     double&nbsp;key,
                                     int&nbsp;from,
                                     int&nbsp;to)</PRE>
<DL>
<DD>Searches the list for the specified value using
 the binary search algorithm.  The list must <strong>must</strong> be
 sorted (as by the sort method) prior to making this call.  If
 it is not sorted, the results are undefined: in particular, the call
 may enter an infinite loop.  If the list contains multiple elements
 equal to the specified key, there is no guarantee which of the multiple elements
 will be found.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>list</CODE> - the list to be searched.<DD><CODE>key</CODE> - the value to be searched for.<DD><CODE>from</CODE> - the leftmost search position, inclusive.<DD><CODE>to</CODE> - the rightmost search position, inclusive.
<DT><B>Returns:</B><DD>index of the search key, if it is contained in the list;
               otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
               point</i> is defined as the the point at which the value would
               be inserted into the list: the index of the first
               element greater than the key, or <tt>list.length</tt>, if all
               elements in the list are less than the specified key.  Note
               that this guarantees that the return value will be &gt;= 0 if
               and only if the key is found.<DT><B>See Also:</B><DD><CODE>Arrays</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="binarySearchFromTo(float[], float, int, int)"><!-- --></A><H3>
binarySearchFromTo</H3>
<PRE>
public static int <B>binarySearchFromTo</B>(float[]&nbsp;list,
                                     float&nbsp;key,
                                     int&nbsp;from,
                                     int&nbsp;to)</PRE>
<DL>
<DD>Searches the list for the specified value using
 the binary search algorithm.  The list must <strong>must</strong> be
 sorted (as by the sort method) prior to making this call.  If
 it is not sorted, the results are undefined: in particular, the call
 may enter an infinite loop.  If the list contains multiple elements
 equal to the specified key, there is no guarantee which of the multiple elements
 will be found.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>list</CODE> - the list to be searched.<DD><CODE>key</CODE> - the value to be searched for.<DD><CODE>from</CODE> - the leftmost search position, inclusive.<DD><CODE>to</CODE> - the rightmost search position, inclusive.
<DT><B>Returns:</B><DD>index of the search key, if it is contained in the list;
               otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
               point</i> is defined as the the point at which the value would
               be inserted into the list: the index of the first
               element greater than the key, or <tt>list.length</tt>, if all
               elements in the list are less than the specified key.  Note
               that this guarantees that the return value will be &gt;= 0 if
               and only if the key is found.<DT><B>See Also:</B><DD><CODE>Arrays</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="binarySearchFromTo(int[], int, int, int)"><!-- --></A><H3>
binarySearchFromTo</H3>
<PRE>
public static int <B>binarySearchFromTo</B>(int[]&nbsp;list,
                                     int&nbsp;key,
                                     int&nbsp;from,
                                     int&nbsp;to)</PRE>
<DL>
<DD>Searches the list for the specified value using
 the binary search algorithm.  The list must <strong>must</strong> be
 sorted (as by the sort method) prior to making this call.  If
 it is not sorted, the results are undefined: in particular, the call
 may enter an infinite loop.  If the list contains multiple elements
 equal to the specified key, there is no guarantee which of the multiple elements
 will be found.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>list</CODE> - the list to be searched.<DD><CODE>key</CODE> - the value to be searched for.<DD><CODE>from</CODE> - the leftmost search position, inclusive.<DD><CODE>to</CODE> - the rightmost search position, inclusive.
<DT><B>Returns:</B><DD>index of the search key, if it is contained in the list;
               otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
               point</i> is defined as the the point at which the value would
               be inserted into the list: the index of the first
               element greater than the key, or <tt>list.length</tt>, if all
               elements in the list are less than the specified key.  Note
               that this guarantees that the return value will be &gt;= 0 if
               and only if the key is found.<DT><B>See Also:</B><DD><CODE>Arrays</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="binarySearchFromTo(long[], long, int, int)"><!-- --></A><H3>
binarySearchFromTo</H3>
<PRE>
public static int <B>binarySearchFromTo</B>(long[]&nbsp;list,
                                     long&nbsp;key,
                                     int&nbsp;from,
                                     int&nbsp;to)</PRE>
<DL>
<DD>Searches the list for the specified value using
 the binary search algorithm.  The list must <strong>must</strong> be
 sorted (as by the sort method) prior to making this call.  If
 it is not sorted, the results are undefined: in particular, the call
 may enter an infinite loop.  If the list contains multiple elements
 equal to the specified key, there is no guarantee which of the multiple elements
 will be found.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>list</CODE> - the list to be searched.<DD><CODE>key</CODE> - the value to be searched for.<DD><CODE>from</CODE> - the leftmost search position, inclusive.<DD><CODE>to</CODE> - the rightmost search position, inclusive.
<DT><B>Returns:</B><DD>index of the search key, if it is contained in the list;
               otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
               point</i> is defined as the the point at which the value would
               be inserted into the list: the index of the first
               element greater than the key, or <tt>list.length</tt>, if all
               elements in the list are less than the specified key.  Note
               that this guarantees that the return value will be &gt;= 0 if
               and only if the key is found.<DT><B>See Also:</B><DD><CODE>Arrays</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="binarySearchFromTo(java.lang.Object[], java.lang.Object, int, int, java.util.Comparator)"><!-- --></A><H3>
binarySearchFromTo</H3>
<PRE>
public static int <B>binarySearchFromTo</B>(java.lang.Object[]&nbsp;list,
                                     java.lang.Object&nbsp;key,
                                     int&nbsp;from,
                                     int&nbsp;to,
                                     java.util.Comparator&nbsp;comparator)</PRE>
<DL>
<DD>Searches the list for the specified value using
 the binary search algorithm. The list must be sorted into ascending order
 according to the specified comparator.  All elements in the
 range must be <i>mutually comparable</i> by the specified comparator
 (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 <tt>e2</tt> in the range).<p>

 If the list is not sorted, the results are undefined: in particular, the call
 may enter an infinite loop.  If the list contains multiple elements
 equal to the specified key, there is no guarantee which instance
 will be found.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>list</CODE> - the list to be searched.<DD><CODE>key</CODE> - the value to be searched for.<DD><CODE>from</CODE> - the leftmost search position, inclusive.<DD><CODE>to</CODE> - the rightmost search position, inclusive.<DD><CODE>comparator</CODE> - the comparator by which the list is sorted.
<DT><B>Returns:</B><DD>index of the search key, if it is contained in the list;
               otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
               point</i> is defined as the the point at which the value would
               be inserted into the list: the index of the first
               element greater than the key, or <tt>list.length</tt>, if all
               elements in the list are less than the specified key.  Note
               that this guarantees that the return value will be &gt;= 0 if
               and only if the key is found.
<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if the list contains elements that are not
               <i>mutually comparable</i> using the specified comparator.<DT><B>See Also:</B><DD><CODE>Arrays</CODE>, 
<CODE>Comparator</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="binarySearchFromTo(short[], short, int, int)"><!-- --></A><H3>
binarySearchFromTo</H3>
<PRE>
public static int <B>binarySearchFromTo</B>(short[]&nbsp;list,
                                     short&nbsp;key,
                                     int&nbsp;from,
                                     int&nbsp;to)</PRE>
<DL>
<DD>Searches the list for the specified value using
 the binary search algorithm.  The list must <strong>must</strong> be
 sorted (as by the sort method) prior to making this call.  If
 it is not sorted, the results are undefined: in particular, the call
 may enter an infinite loop.  If the list contains multiple elements
 equal to the specified key, there is no guarantee which of the multiple elements
 will be found.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>list</CODE> - the list to be searched.<DD><CODE>key</CODE> - the value to be searched for.<DD><CODE>from</CODE> - the leftmost search position, inclusive.<DD><CODE>to</CODE> - the rightmost search position, inclusive.
<DT><B>Returns:</B><DD>index of the search key, if it is contained in the list;
               otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
               point</i> is defined as the the point at which the value would
               be inserted into the list: the index of the first
               element greater than the key, or <tt>list.length</tt>, if all
               elements in the list are less than the specified key.  Note
               that this guarantees that the return value will be &gt;= 0 if
               and only if the key is found.<DT><B>See Also:</B><DD><CODE>Arrays</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="binarySearchFromTo(int, int, cern.colt.function.IntComparator)"><!-- --></A><H3>
binarySearchFromTo</H3>
<PRE>
public static int <B>binarySearchFromTo</B>(int&nbsp;from,
                                     int&nbsp;to,
                                     <A HREF="../../cern/colt/function/IntComparator.html" title="interface in cern.colt.function">IntComparator</A>&nbsp;comp)</PRE>
<DL>
<DD>Generically searches the list for the specified value using
 the binary search algorithm.  The list must <strong>must</strong> be
 sorted (as by the sort method) prior to making this call.  If
 it is not sorted, the results are undefined: in particular, the call
 may enter an infinite loop.  If the list contains multiple elements
 equal to the specified key, there is no guarantee which of the multiple elements
 will be found.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>list</CODE> - the list to be searched.<DD><CODE>key</CODE> - the value to be searched for.<DD><CODE>from</CODE> - the leftmost search position, inclusive.<DD><CODE>to</CODE> - the rightmost search position, inclusive.
<DT><B>Returns:</B><DD>index of the search key, if it is contained in the list;
               otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
               point</i> is defined as the the point at which the value would
               be inserted into the list: the index of the first
               element greater than the key, or <tt>list.length</tt>, if all
               elements in the list are less than the specified key.  Note
               that this guarantees that the return value will be &gt;= 0 if
               and only if the key is found.<DT><B>See Also:</B><DD><CODE>Arrays</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="mergeSort(byte[], int, int)"><!-- --></A><H3>
mergeSort</H3>
<PRE>
public static void <B>mergeSort</B>(byte[]&nbsp;a,
                             int&nbsp;fromIndex,
                             int&nbsp;toIndex)</PRE>
<DL>
<DD>Sorts the specified range of the specified array of elements.

 <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
 not be reordered as a result of the sort.<p>

 The sorting algorithm is a modified mergesort (in which the merge is
 omitted if the highest element in the low sublist is less than the
 lowest element in the high sublist).  This algorithm offers guaranteed
 n*log(n) performance, and can approach linear performance on nearly
 sorted lists.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.<DD><CODE>fromIndex</CODE> - the index of the first element (inclusive) to be
        sorted.<DD><CODE>toIndex</CODE> - the index of the last element (exclusive) to be sorted.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>fromIndex &gt; toIndex</tt>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <tt>fromIndex &lt; 0</tt> or
               <tt>toIndex &gt; a.length</tt></DL>
</DD>
</DL>
<HR>

<A NAME="mergeSort(byte[], int, int, cern.colt.function.ByteComparator)"><!-- --></A><H3>
mergeSort</H3>
<PRE>
public static void <B>mergeSort</B>(byte[]&nbsp;a,
                             int&nbsp;fromIndex,
                             int&nbsp;toIndex,
                             <A HREF="../../cern/colt/function/ByteComparator.html" title="interface in cern.colt.function">ByteComparator</A>&nbsp;c)</PRE>
<DL>
<DD>Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.  All elements in the
 range must be <i>mutually comparable</i> by the specified comparator
 (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 <tt>e2</tt> in the range).<p>

 This sort is guaranteed to be <i>stable</i>:  equal elements will
 not be reordered as a result of the sort.<p>

 The sorting algorithm is a modified mergesort (in which the merge is
 omitted if the highest element in the low sublist is less than the
 lowest element in the high sublist).  This algorithm offers guaranteed
 n*log(n) performance, and can approach linear performance on nearly
 sorted lists.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.<DD><CODE>fromIndex</CODE> - the index of the first element (inclusive) to be
        sorted.<DD><CODE>toIndex</CODE> - the index of the last element (exclusive) to be sorted.<DD><CODE>c</CODE> - the comparator to determine the order of the array.
<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if the array contains elements that are not
               <i>mutually comparable</i> using the specified comparator.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>fromIndex &gt; toIndex</tt>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <tt>fromIndex &lt; 0</tt> or
               <tt>toIndex &gt; a.length</tt><DT><B>See Also:</B><DD><CODE>Comparator</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="mergeSort(char[], int, int)"><!-- --></A><H3>
mergeSort</H3>
<PRE>
public static void <B>mergeSort</B>(char[]&nbsp;a,
                             int&nbsp;fromIndex,
                             int&nbsp;toIndex)</PRE>
<DL>
<DD>Sorts the specified range of the specified array of elements.

 <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
 not be reordered as a result of the sort.<p>

 The sorting algorithm is a modified mergesort (in which the merge is
 omitted if the highest element in the low sublist is less than the
 lowest element in the high sublist).  This algorithm offers guaranteed
 n*log(n) performance, and can approach linear performance on nearly
 sorted lists.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.<DD><CODE>fromIndex</CODE> - the index of the first element (inclusive) to be
        sorted.<DD><CODE>toIndex</CODE> - the index of the last element (exclusive) to be sorted.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>fromIndex &gt; toIndex</tt>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <tt>fromIndex &lt; 0</tt> or
               <tt>toIndex &gt; a.length</tt></DL>
</DD>
</DL>
<HR>

<A NAME="mergeSort(char[], int, int, cern.colt.function.CharComparator)"><!-- --></A><H3>
mergeSort</H3>
<PRE>
public static void <B>mergeSort</B>(char[]&nbsp;a,
                             int&nbsp;fromIndex,
                             int&nbsp;toIndex,
                             <A HREF="../../cern/colt/function/CharComparator.html" title="interface in cern.colt.function">CharComparator</A>&nbsp;c)</PRE>
<DL>
<DD>Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.  All elements in the
 range must be <i>mutually comparable</i> by the specified comparator
 (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 <tt>e2</tt> in the range).<p>

 This sort is guaranteed to be <i>stable</i>:  equal elements will
 not be reordered as a result of the sort.<p>

 The sorting algorithm is a modified mergesort (in which the merge is
 omitted if the highest element in the low sublist is less than the
 lowest element in the high sublist).  This algorithm offers guaranteed
 n*log(n) performance, and can approach linear performance on nearly
 sorted lists.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.<DD><CODE>fromIndex</CODE> - the index of the first element (inclusive) to be
        sorted.<DD><CODE>toIndex</CODE> - the index of the last element (exclusive) to be sorted.<DD><CODE>c</CODE> - the comparator to determine the order of the array.
<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if the array contains elements that are not
               <i>mutually comparable</i> using the specified comparator.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>fromIndex &gt; toIndex</tt>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <tt>fromIndex &lt; 0</tt> or
               <tt>toIndex &gt; a.length</tt><DT><B>See Also:</B><DD><CODE>Comparator</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="mergeSort(double[], int, int)"><!-- --></A><H3>
mergeSort</H3>
<PRE>
public static void <B>mergeSort</B>(double[]&nbsp;a,
                             int&nbsp;fromIndex,
                             int&nbsp;toIndex)</PRE>
<DL>
<DD>Sorts the specified range of the specified array of elements.

 <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
 not be reordered as a result of the sort.<p>

 The sorting algorithm is a modified mergesort (in which the merge is
 omitted if the highest element in the low sublist is less than the
 lowest element in the high sublist).  This algorithm offers guaranteed
 n*log(n) performance, and can approach linear performance on nearly
 sorted lists.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.<DD><CODE>fromIndex</CODE> - the index of the first element (inclusive) to be
        sorted.<DD><CODE>toIndex</CODE> - the index of the last element (exclusive) to be sorted.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>fromIndex &gt; toIndex</tt>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <tt>fromIndex &lt; 0</tt> or
               <tt>toIndex &gt; a.length</tt></DL>
</DD>
</DL>
<HR>

<A NAME="mergeSort(double[], int, int, cern.colt.function.DoubleComparator)"><!-- --></A><H3>
mergeSort</H3>
<PRE>
public static void <B>mergeSort</B>(double[]&nbsp;a,
                             int&nbsp;fromIndex,
                             int&nbsp;toIndex,
                             <A HREF="../../cern/colt/function/DoubleComparator.html" title="interface in cern.colt.function">DoubleComparator</A>&nbsp;c)</PRE>
<DL>
<DD>Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.  All elements in the
 range must be <i>mutually comparable</i> by the specified comparator
 (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 <tt>e2</tt> in the range).<p>

 This sort is guaranteed to be <i>stable</i>:  equal elements will
 not be reordered as a result of the sort.<p>

 The sorting algorithm is a modified mergesort (in which the merge is
 omitted if the highest element in the low sublist is less than the
 lowest element in the high sublist).  This algorithm offers guaranteed
 n*log(n) performance, and can approach linear performance on nearly
 sorted lists.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.<DD><CODE>fromIndex</CODE> - the index of the first element (inclusive) to be
        sorted.<DD><CODE>toIndex</CODE> - the index of the last element (exclusive) to be sorted.<DD><CODE>c</CODE> - the comparator to determine the order of the array.
<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if the array contains elements that are not
               <i>mutually comparable</i> using the specified comparator.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>fromIndex &gt; toIndex</tt>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <tt>fromIndex &lt; 0</tt> or
               <tt>toIndex &gt; a.length</tt><DT><B>See Also:</B><DD><CODE>Comparator</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="mergeSort(float[], int, int)"><!-- --></A><H3>
mergeSort</H3>
<PRE>
public static void <B>mergeSort</B>(float[]&nbsp;a,
                             int&nbsp;fromIndex,
                             int&nbsp;toIndex)</PRE>
<DL>
<DD>Sorts the specified range of the specified array of elements.

 <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
 not be reordered as a result of the sort.<p>

 The sorting algorithm is a modified mergesort (in which the merge is
 omitted if the highest element in the low sublist is less than the
 lowest element in the high sublist).  This algorithm offers guaranteed
 n*log(n) performance, and can approach linear performance on nearly
 sorted lists.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.<DD><CODE>fromIndex</CODE> - the index of the first element (inclusive) to be
        sorted.<DD><CODE>toIndex</CODE> - the index of the last element (exclusive) to be sorted.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>fromIndex &gt; toIndex</tt>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <tt>fromIndex &lt; 0</tt> or
               <tt>toIndex &gt; a.length</tt></DL>
</DD>
</DL>
<HR>

<A NAME="mergeSort(float[], int, int, cern.colt.function.FloatComparator)"><!-- --></A><H3>
mergeSort</H3>
<PRE>
public static void <B>mergeSort</B>(float[]&nbsp;a,
                             int&nbsp;fromIndex,
                             int&nbsp;toIndex,
                             <A HREF="../../cern/colt/function/FloatComparator.html" title="interface in cern.colt.function">FloatComparator</A>&nbsp;c)</PRE>
<DL>
<DD>Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.  All elements in the
 range must be <i>mutually comparable</i> by the specified comparator
 (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 <tt>e2</tt> in the range).<p>

 This sort is guaranteed to be <i>stable</i>:  equal elements will
 not be reordered as a result of the sort.<p>

 The sorting algorithm is a modified mergesort (in which the merge is
 omitted if the highest element in the low sublist is less than the
 lowest element in the high sublist).  This algorithm offers guaranteed
 n*log(n) performance, and can approach linear performance on nearly
 sorted lists.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.<DD><CODE>fromIndex</CODE> - the index of the first element (inclusive) to be
        sorted.<DD><CODE>toIndex</CODE> - the index of the last element (exclusive) to be sorted.<DD><CODE>c</CODE> - the comparator to determine the order of the array.
<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if the array contains elements that are not
               <i>mutually comparable</i> using the specified comparator.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>fromIndex &gt; toIndex</tt>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <tt>fromIndex &lt; 0</tt> or
               <tt>toIndex &gt; a.length</tt><DT><B>See Also:</B><DD><CODE>Comparator</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="mergeSort(int[], int, int)"><!-- --></A><H3>
mergeSort</H3>
<PRE>
public static void <B>mergeSort</B>(int[]&nbsp;a,
                             int&nbsp;fromIndex,
                             int&nbsp;toIndex)</PRE>
<DL>
<DD>Sorts the specified range of the specified array of elements.

 <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
 not be reordered as a result of the sort.<p>

 The sorting algorithm is a modified mergesort (in which the merge is
 omitted if the highest element in the low sublist is less than the
 lowest element in the high sublist).  This algorithm offers guaranteed
 n*log(n) performance, and can approach linear performance on nearly
 sorted lists.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.<DD><CODE>fromIndex</CODE> - the index of the first element (inclusive) to be
        sorted.<DD><CODE>toIndex</CODE> - the index of the last element (exclusive) to be sorted.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>fromIndex &gt; toIndex</tt>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <tt>fromIndex &lt; 0</tt> or
               <tt>toIndex &gt; a.length</tt></DL>
</DD>
</DL>
<HR>

<A NAME="mergeSort(int[], int, int, cern.colt.function.IntComparator)"><!-- --></A><H3>
mergeSort</H3>
<PRE>
public static void <B>mergeSort</B>(int[]&nbsp;a,
                             int&nbsp;fromIndex,
                             int&nbsp;toIndex,
                             <A HREF="../../cern/colt/function/IntComparator.html" title="interface in cern.colt.function">IntComparator</A>&nbsp;c)</PRE>
<DL>
<DD>Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.  All elements in the
 range must be <i>mutually comparable</i> by the specified comparator
 (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 <tt>e2</tt> in the range).<p>

 This sort is guaranteed to be <i>stable</i>:  equal elements will
 not be reordered as a result of the sort.<p>

 The sorting algorithm is a modified mergesort (in which the merge is
 omitted if the highest element in the low sublist is less than the
 lowest element in the high sublist).  This algorithm offers guaranteed
 n*log(n) performance, and can approach linear performance on nearly
 sorted lists.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.<DD><CODE>fromIndex</CODE> - the index of the first element (inclusive) to be
        sorted.<DD><CODE>toIndex</CODE> - the index of the last element (exclusive) to be sorted.<DD><CODE>c</CODE> - the comparator to determine the order of the array.
<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if the array contains elements that are not
               <i>mutually comparable</i> using the specified comparator.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>fromIndex &gt; toIndex</tt>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <tt>fromIndex &lt; 0</tt> or
               <tt>toIndex &gt; a.length</tt><DT><B>See Also:</B><DD><CODE>Comparator</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="mergeSort(long[], int, int)"><!-- --></A><H3>
mergeSort</H3>
<PRE>
public static void <B>mergeSort</B>(long[]&nbsp;a,
                             int&nbsp;fromIndex,
                             int&nbsp;toIndex)</PRE>
<DL>
<DD>Sorts the specified range of the specified array of elements.

 <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
 not be reordered as a result of the sort.<p>

 The sorting algorithm is a modified mergesort (in which the merge is
 omitted if the highest element in the low sublist is less than the
 lowest element in the high sublist).  This algorithm offers guaranteed
 n*log(n) performance, and can approach linear performance on nearly
 sorted lists.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.<DD><CODE>fromIndex</CODE> - the index of the first element (inclusive) to be
        sorted.<DD><CODE>toIndex</CODE> - the index of the last element (exclusive) to be sorted.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>fromIndex &gt; toIndex</tt>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <tt>fromIndex &lt; 0</tt> or
               <tt>toIndex &gt; a.length</tt></DL>
</DD>
</DL>
<HR>

<A NAME="mergeSort(long[], int, int, cern.colt.function.LongComparator)"><!-- --></A><H3>
mergeSort</H3>
<PRE>
public static void <B>mergeSort</B>(long[]&nbsp;a,
                             int&nbsp;fromIndex,
                             int&nbsp;toIndex,
                             <A HREF="../../cern/colt/function/LongComparator.html" title="interface in cern.colt.function">LongComparator</A>&nbsp;c)</PRE>
<DL>
<DD>Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.  All elements in the
 range must be <i>mutually comparable</i> by the specified comparator
 (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 <tt>e2</tt> in the range).<p>

 This sort is guaranteed to be <i>stable</i>:  equal elements will
 not be reordered as a result of the sort.<p>

 The sorting algorithm is a modified mergesort (in which the merge is
 omitted if the highest element in the low sublist is less than the
 lowest element in the high sublist).  This algorithm offers guaranteed
 n*log(n) performance, and can approach linear performance on nearly
 sorted lists.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.<DD><CODE>fromIndex</CODE> - the index of the first element (inclusive) to be
        sorted.<DD><CODE>toIndex</CODE> - the index of the last element (exclusive) to be sorted.<DD><CODE>c</CODE> - the comparator to determine the order of the array.
<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if the array contains elements that are not
               <i>mutually comparable</i> using the specified comparator.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>fromIndex &gt; toIndex</tt>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <tt>fromIndex &lt; 0</tt> or
               <tt>toIndex &gt; a.length</tt><DT><B>See Also:</B><DD><CODE>Comparator</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="mergeSort(short[], int, int)"><!-- --></A><H3>
mergeSort</H3>
<PRE>
public static void <B>mergeSort</B>(short[]&nbsp;a,
                             int&nbsp;fromIndex,
                             int&nbsp;toIndex)</PRE>
<DL>
<DD>Sorts the specified range of the specified array of elements.

 <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
 not be reordered as a result of the sort.<p>

 The sorting algorithm is a modified mergesort (in which the merge is
 omitted if the highest element in the low sublist is less than the
 lowest element in the high sublist).  This algorithm offers guaranteed
 n*log(n) performance, and can approach linear performance on nearly
 sorted lists.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.<DD><CODE>fromIndex</CODE> - the index of the first element (inclusive) to be
        sorted.<DD><CODE>toIndex</CODE> - the index of the last element (exclusive) to be sorted.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>fromIndex &gt; toIndex</tt>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <tt>fromIndex &lt; 0</tt> or
               <tt>toIndex &gt; a.length</tt></DL>
</DD>
</DL>
<HR>

<A NAME="mergeSort(short[], int, int, cern.colt.function.ShortComparator)"><!-- --></A><H3>
mergeSort</H3>
<PRE>
public static void <B>mergeSort</B>(short[]&nbsp;a,
                             int&nbsp;fromIndex,
                             int&nbsp;toIndex,
                             <A HREF="../../cern/colt/function/ShortComparator.html" title="interface in cern.colt.function">ShortComparator</A>&nbsp;c)</PRE>
<DL>
<DD>Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.  All elements in the
 range must be <i>mutually comparable</i> by the specified comparator
 (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 <tt>e2</tt> in the range).<p>

 This sort is guaranteed to be <i>stable</i>:  equal elements will
 not be reordered as a result of the sort.<p>

 The sorting algorithm is a modified mergesort (in which the merge is
 omitted if the highest element in the low sublist is less than the
 lowest element in the high sublist).  This algorithm offers guaranteed
 n*log(n) performance, and can approach linear performance on nearly
 sorted lists.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.<DD><CODE>fromIndex</CODE> - the index of the first element (inclusive) to be
        sorted.<DD><CODE>toIndex</CODE> - the index of the last element (exclusive) to be sorted.<DD><CODE>c</CODE> - the comparator to determine the order of the array.
<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if the array contains elements that are not
               <i>mutually comparable</i> using the specified comparator.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>fromIndex &gt; toIndex</tt>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <tt>fromIndex &lt; 0</tt> or
               <tt>toIndex &gt; a.length</tt><DT><B>See Also:</B><DD><CODE>Comparator</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="mergeSortInPlace(int[], int, int)"><!-- --></A><H3>
mergeSortInPlace</H3>
<PRE>
public static void <B>mergeSortInPlace</B>(int[]&nbsp;a,
                                    int&nbsp;fromIndex,
                                    int&nbsp;toIndex)</PRE>
<DL>
<DD>Sorts the specified range of the specified array of elements.

 <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
 not be reordered as a result of the sort.<p>

 The sorting algorithm is a modified mergesort (in which the merge is
 omitted if the highest element in the low sublist is less than the
 lowest element in the high sublist).  This algorithm offers guaranteed
 n*log(n) performance, and can approach linear performance on nearly
 sorted lists.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.<DD><CODE>fromIndex</CODE> - the index of the first element (inclusive) to be
        sorted.<DD><CODE>toIndex</CODE> - the index of the last element (exclusive) to be sorted.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>fromIndex &gt; toIndex</tt>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <tt>fromIndex &lt; 0</tt> or
               <tt>toIndex &gt; a.length</tt></DL>
</DD>
</DL>
<HR>

<A NAME="quickSort(byte[], int, int, cern.colt.function.ByteComparator)"><!-- --></A><H3>
quickSort</H3>
<PRE>
public static void <B>quickSort</B>(byte[]&nbsp;a,
                             int&nbsp;fromIndex,
                             int&nbsp;toIndex,
                             <A HREF="../../cern/colt/function/ByteComparator.html" title="interface in cern.colt.function">ByteComparator</A>&nbsp;c)</PRE>
<DL>
<DD>Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.  All elements in the
 range must be <i>mutually comparable</i> by the specified comparator
 (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 <tt>e2</tt> in the range).<p>

 The sorting algorithm is a tuned quicksort,
 adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 Sort Function", Software-Practice and Experience, Vol. 23(11)
 P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 performance on many data sets that cause other quicksorts to degrade to
 quadratic performance.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.<DD><CODE>fromIndex</CODE> - the index of the first element (inclusive) to be
        sorted.<DD><CODE>toIndex</CODE> - the index of the last element (exclusive) to be sorted.<DD><CODE>c</CODE> - the comparator to determine the order of the array.
<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if the array contains elements that are not
               <i>mutually comparable</i> using the specified comparator.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>fromIndex &gt; toIndex</tt>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <tt>fromIndex &lt; 0</tt> or
               <tt>toIndex &gt; a.length</tt><DT><B>See Also:</B><DD><CODE>Comparator</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="quickSort(char[], int, int, cern.colt.function.CharComparator)"><!-- --></A><H3>
quickSort</H3>
<PRE>
public static void <B>quickSort</B>(char[]&nbsp;a,
                             int&nbsp;fromIndex,
                             int&nbsp;toIndex,
                             <A HREF="../../cern/colt/function/CharComparator.html" title="interface in cern.colt.function">CharComparator</A>&nbsp;c)</PRE>
<DL>
<DD>Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.  All elements in the
 range must be <i>mutually comparable</i> by the specified comparator
 (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 <tt>e2</tt> in the range).<p>

 The sorting algorithm is a tuned quicksort,
 adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 Sort Function", Software-Practice and Experience, Vol. 23(11)
 P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 performance on many data sets that cause other quicksorts to degrade to
 quadratic performance.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.<DD><CODE>fromIndex</CODE> - the index of the first element (inclusive) to be
        sorted.<DD><CODE>toIndex</CODE> - the index of the last element (exclusive) to be sorted.<DD><CODE>c</CODE> - the comparator to determine the order of the array.
<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if the array contains elements that are not
               <i>mutually comparable</i> using the specified comparator.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>fromIndex &gt; toIndex</tt>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <tt>fromIndex &lt; 0</tt> or
               <tt>toIndex &gt; a.length</tt><DT><B>See Also:</B><DD><CODE>Comparator</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="quickSort(double[], int, int, cern.colt.function.DoubleComparator)"><!-- --></A><H3>
quickSort</H3>
<PRE>
public static void <B>quickSort</B>(double[]&nbsp;a,
                             int&nbsp;fromIndex,
                             int&nbsp;toIndex,
                             <A HREF="../../cern/colt/function/DoubleComparator.html" title="interface in cern.colt.function">DoubleComparator</A>&nbsp;c)</PRE>
<DL>
<DD>Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.  All elements in the
 range must be <i>mutually comparable</i> by the specified comparator
 (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 <tt>e2</tt> in the range).<p>

 The sorting algorithm is a tuned quicksort,
 adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 Sort Function", Software-Practice and Experience, Vol. 23(11)
 P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 performance on many data sets that cause other quicksorts to degrade to
 quadratic performance.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.<DD><CODE>fromIndex</CODE> - the index of the first element (inclusive) to be
        sorted.<DD><CODE>toIndex</CODE> - the index of the last element (exclusive) to be sorted.<DD><CODE>c</CODE> - the comparator to determine the order of the array.
<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if the array contains elements that are not
               <i>mutually comparable</i> using the specified comparator.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>fromIndex &gt; toIndex</tt>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <tt>fromIndex &lt; 0</tt> or
               <tt>toIndex &gt; a.length</tt><DT><B>See Also:</B><DD><CODE>Comparator</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="quickSort(float[], int, int, cern.colt.function.FloatComparator)"><!-- --></A><H3>
quickSort</H3>
<PRE>
public static void <B>quickSort</B>(float[]&nbsp;a,
                             int&nbsp;fromIndex,
                             int&nbsp;toIndex,
                             <A HREF="../../cern/colt/function/FloatComparator.html" title="interface in cern.colt.function">FloatComparator</A>&nbsp;c)</PRE>
<DL>
<DD>Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.  All elements in the
 range must be <i>mutually comparable</i> by the specified comparator
 (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 <tt>e2</tt> in the range).<p>

 The sorting algorithm is a tuned quicksort,
 adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 Sort Function", Software-Practice and Experience, Vol. 23(11)
 P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 performance on many data sets that cause other quicksorts to degrade to
 quadratic performance.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.<DD><CODE>fromIndex</CODE> - the index of the first element (inclusive) to be
        sorted.<DD><CODE>toIndex</CODE> - the index of the last element (exclusive) to be sorted.<DD><CODE>c</CODE> - the comparator to determine the order of the array.
<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if the array contains elements that are not
               <i>mutually comparable</i> using the specified comparator.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>fromIndex &gt; toIndex</tt>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <tt>fromIndex &lt; 0</tt> or
               <tt>toIndex &gt; a.length</tt><DT><B>See Also:</B><DD><CODE>Comparator</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="quickSort(int[], int, int, cern.colt.function.IntComparator)"><!-- --></A><H3>
quickSort</H3>
<PRE>
public static void <B>quickSort</B>(int[]&nbsp;a,
                             int&nbsp;fromIndex,
                             int&nbsp;toIndex,
                             <A HREF="../../cern/colt/function/IntComparator.html" title="interface in cern.colt.function">IntComparator</A>&nbsp;c)</PRE>
<DL>
<DD>Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.  All elements in the
 range must be <i>mutually comparable</i> by the specified comparator
 (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 <tt>e2</tt> in the range).<p>

 The sorting algorithm is a tuned quicksort,
 adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 Sort Function", Software-Practice and Experience, Vol. 23(11)
 P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 performance on many data sets that cause other quicksorts to degrade to
 quadratic performance.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.<DD><CODE>fromIndex</CODE> - the index of the first element (inclusive) to be
        sorted.<DD><CODE>toIndex</CODE> - the index of the last element (exclusive) to be sorted.<DD><CODE>c</CODE> - the comparator to determine the order of the array.
<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if the array contains elements that are not
               <i>mutually comparable</i> using the specified comparator.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>fromIndex &gt; toIndex</tt>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <tt>fromIndex &lt; 0</tt> or
               <tt>toIndex &gt; a.length</tt><DT><B>See Also:</B><DD><CODE>Comparator</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="quickSort(long[], int, int, cern.colt.function.LongComparator)"><!-- --></A><H3>
quickSort</H3>
<PRE>
public static void <B>quickSort</B>(long[]&nbsp;a,
                             int&nbsp;fromIndex,
                             int&nbsp;toIndex,
                             <A HREF="../../cern/colt/function/LongComparator.html" title="interface in cern.colt.function">LongComparator</A>&nbsp;c)</PRE>
<DL>
<DD>Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.  All elements in the
 range must be <i>mutually comparable</i> by the specified comparator
 (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 <tt>e2</tt> in the range).<p>

 The sorting algorithm is a tuned quicksort,
 adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 Sort Function", Software-Practice and Experience, Vol. 23(11)
 P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 performance on many data sets that cause other quicksorts to degrade to
 quadratic performance.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.<DD><CODE>fromIndex</CODE> - the index of the first element (inclusive) to be
        sorted.<DD><CODE>toIndex</CODE> - the index of the last element (exclusive) to be sorted.<DD><CODE>c</CODE> - the comparator to determine the order of the array.
<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if the array contains elements that are not
               <i>mutually comparable</i> using the specified comparator.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>fromIndex &gt; toIndex</tt>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <tt>fromIndex &lt; 0</tt> or
               <tt>toIndex &gt; a.length</tt><DT><B>See Also:</B><DD><CODE>Comparator</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="quickSort(java.lang.Object[])"><!-- --></A><H3>
quickSort</H3>
<PRE>
public static void <B>quickSort</B>(java.lang.Object[]&nbsp;a)</PRE>
<DL>
<DD>Sorts the specified range of the receiver into
 ascending order, according to the <i>natural ordering</i> of its
 elements.  All elements in this range must implement the
 <tt>Comparable</tt> interface.  Furthermore, all elements in this range
 must be <i>mutually comparable</i> (that is, <tt>e1.compareTo(e2)</tt>
 must not throw a <tt>ClassCastException</tt> for any elements
 <tt>e1</tt> and <tt>e2</tt> in the array).<p>

 The sorting algorithm is a tuned quicksort, adapted from Jon
 L. Bentley and M. Douglas McIlroy's "Engineering a Sort Function",
 Software-Practice and Experience, Vol. 23(11) P. 1249-1265 (November
 1993).  This algorithm offers n*log(n) performance on many data sets
 that cause other quicksorts to degrade to quadratic performance.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.</DL>
</DD>
</DL>
<HR>

<A NAME="quickSort(java.lang.Object[], int, int)"><!-- --></A><H3>
quickSort</H3>
<PRE>
public static void <B>quickSort</B>(java.lang.Object[]&nbsp;a,
                             int&nbsp;fromIndex,
                             int&nbsp;toIndex)</PRE>
<DL>
<DD>Sorts the specified range of the receiver into
 ascending order, according to the <i>natural ordering</i> of its
 elements.  All elements in this range must implement the
 <tt>Comparable</tt> interface.  Furthermore, all elements in this range
 must be <i>mutually comparable</i> (that is, <tt>e1.compareTo(e2)</tt>
 must not throw a <tt>ClassCastException</tt> for any elements
 <tt>e1</tt> and <tt>e2</tt> in the array).<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.<DD><CODE>fromIndex</CODE> - the index of the first element (inclusive) to be
        sorted.<DD><CODE>toIndex</CODE> - the index of the last element (exclusive) to be sorted.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>fromIndex &gt; toIndex</tt>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <tt>fromIndex &lt; 0</tt> or
               <tt>toIndex &gt; a.length</tt></DL>
</DD>
</DL>
<HR>

<A NAME="quickSort(java.lang.Object[], int, int, java.util.Comparator)"><!-- --></A><H3>
quickSort</H3>
<PRE>
public static void <B>quickSort</B>(java.lang.Object[]&nbsp;a,
                             int&nbsp;fromIndex,
                             int&nbsp;toIndex,
                             java.util.Comparator&nbsp;c)</PRE>
<DL>
<DD>Sorts the specified range of the specified array according
 to the order induced by the specified comparator.  All elements in the
 range must be <i>mutually comparable</i> by the specified comparator
 (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 <tt>e2</tt> in the range).<p>

 The sorting algorithm is a tuned quicksort,
 adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 Sort Function", Software-Practice and Experience, Vol. 23(11)
 P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 performance on many data sets that cause other quicksorts to degrade to
 quadratic performance.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.<DD><CODE>fromIndex</CODE> - the index of the first element (inclusive) to be
        sorted.<DD><CODE>toIndex</CODE> - the index of the last element (exclusive) to be sorted.<DD><CODE>c</CODE> - the comparator to determine the order of the receiver.
<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if the array contains elements that are not
               <i>mutually comparable</i> using the specified comparator.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>fromIndex &gt; toIndex</tt>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <tt>fromIndex &lt; 0</tt> or
               <tt>toIndex &gt; a.length</tt><DT><B>See Also:</B><DD><CODE>Comparator</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="quickSort(java.lang.Object[], java.util.Comparator)"><!-- --></A><H3>
quickSort</H3>
<PRE>
public static void <B>quickSort</B>(java.lang.Object[]&nbsp;a,
                             java.util.Comparator&nbsp;c)</PRE>
<DL>
<DD>Sorts the specified array according
 to the order induced by the specified comparator.  All elements in the
 range must be <i>mutually comparable</i> by the specified comparator
 (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 <tt>e2</tt> in the range).<p>

 The sorting algorithm is a tuned quicksort,
 adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a
 Sort Function", Software-Practice and Experience, Vol. 23(11)
 P. 1249-1265 (November 1993).  This algorithm offers n*log(n)
 performance on many data sets that cause other quicksorts to degrade to
 quadratic performance.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.<DD><CODE>c</CODE> - the comparator to determine the order of the receiver.
<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if the array contains elements that are not
               <i>mutually comparable</i> using the specified comparator.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>fromIndex &gt; toIndex</tt>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <tt>fromIndex &lt; 0</tt> or
               <tt>toIndex &gt; a.length</tt><DT><B>See Also:</B><DD><CODE>Comparator</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="quickSort(short[], int, int, cern.colt.function.ShortComparator)"><!-- --></A><H3>
quickSort</H3>
<PRE>
public static void <B>quickSort</B>(short[]&nbsp;a,
                             int&nbsp;fromIndex,
                             int&nbsp;toIndex,
                             <A HREF="../../cern/colt/function/ShortComparator.html" title="interface in cern.colt.function">ShortComparator</A>&nbsp;c)</PRE>
<DL>
<DD>Sorts the specified range of the specified array of elements according
 to the order induced by the specified comparator.  All elements in the
 range must be <i>mutually comparable</i> by the specified comparator
 (that is, <tt>c.compare(e1, e2)</tt> must not throw a
 <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
 <tt>e2</tt> in the range).<p>

 This sort is guaranteed to be <i>stable</i>:  equal elements will
 not be reordered as a result of the sort.<p>

 The sorting algorithm is a modified mergesort (in which the merge is
 omitted if the highest element in the low sublist is less than the
 lowest element in the high sublist).  This algorithm offers guaranteed
 n*log(n) performance, and can approach linear performance on nearly
 sorted lists.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - the array to be sorted.<DD><CODE>fromIndex</CODE> - the index of the first element (inclusive) to be
        sorted.<DD><CODE>toIndex</CODE> - the index of the last element (exclusive) to be sorted.<DD><CODE>c</CODE> - the comparator to determine the order of the array.
<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if the array contains elements that are not
               <i>mutually comparable</i> using the specified comparator.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>fromIndex &gt; toIndex</tt>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <tt>fromIndex &lt; 0</tt> or
               <tt>toIndex &gt; a.length</tt><DT><B>See Also:</B><DD><CODE>Comparator</CODE></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../cern/colt/PersistentObject.html" title="class in cern.colt"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../cern/colt/Swapper.html" title="interface in cern.colt"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?cern/colt/Sorting.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Sorting.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
